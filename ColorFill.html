<html><head><base href="/" />
<title>Color Territory Game</title>
<style>
    body {
        display: flex;
        flex-direction: column;
        align-items: center;
        font-family: Arial, sans-serif;
        transition: all 0.3s ease;
    }

    .theme-dark {
        background: #1a1a1a;
        color: white;
    }

    .theme-light {  
        background: #f0f0f0;
        color: #333;
    }

    #gameContainer {
        margin: 20px;
    }

    canvas {
        border: 2px solid #333;
        transition: border-color 0.3s ease;
    }

    .theme-dark canvas {
        background: #222;
    }

    .theme-light canvas {
        background: #fff;
    }

    .controls {
        margin: 20px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: center;
    }

    .color-buttons {
        display: flex;
        gap: 10px;
    }

    .button {
        padding: 8px 16px;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.2s;
        border: none;
        font-size: 14px;
    }

    .theme-dark .button {
        background: #444;
        color: white;
    }

    .theme-light .button {
        background: #ddd;
        color: #333;
    }

    .button:hover {
        transform: scale(1.05);
    }

    .color-btn {
        width: 40px;
        height: 40px;
        border: 2px solid white;
        border-radius: 50%;
        cursor: pointer;
        transition: transform 0.2s;
        opacity: 0.5;
    }

    .color-btn.available {
        opacity: 1;
    }

    .color-btn:hover.available {
        transform: scale(1.1);
    }

    #status {
        font-size: 1.2em;
        margin: 10px;
        padding: 10px;
        border-radius: 5px;
        transition: background 0.3s ease;
        color: #0074D9; /* Blue text color */
    }

    .theme-dark #status {
        background: #333;
    }

    .theme-light #status {
        background: #ddd;
    }

    .score {
        display: flex;
        gap: 20px;
        margin: 10px;
    }

    .player-score {
        padding: 10px;
        border-radius: 5px;
        transition: all 0.3s ease;
        position: relative; /* Add this */
    }

    .theme-dark .player-score { background: #444; }
    .theme-light .player-score { background: #ddd; }

    .winner-announcement {
        font-size: 2em;
        color: gold;
        text-shadow: 0 0 10px rgba(255,215,0,0.5);
        animation: celebrate 1s ease infinite;
    }

    @keyframes celebrate {
        0% { transform: scale(1); }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); }
    }

    /* Add glow animation for current player territory */
    @keyframes territoryGlow {
        0% { box-shadow: 0 0 5px yellow; }
        50% { box-shadow: 0 0 15px yellow; }
        100% { box-shadow: 0 0 5px yellow; }
    }

    .game-controls {
        display: flex;
        gap: 20px;
        margin: 10px;
        align-items: center;
    }

    .grid-size-controls {
        display: flex;
        gap: 10px;
        align-items: center;
    }

    .grid-size-controls input {
        width: 60px;
        padding: 5px;
        border-radius: 5px;
        border: 1px solid #666;
        background: transparent;
        color: inherit;
    }

    .theme-dark .grid-size-controls input {
        border-color: #666;
        color: white;
    }

    .theme-light .grid-size-controls input {
        border-color: #999;
        color: #333;
    }

    .grid-size-controls label {
        font-size: 14px;
    }

    .player-score.current {
        animation: scoreGlow 1.5s ease-in-out infinite;
    }

    .player-score.winner {
        animation: winnerScoreGlow 1.5s ease-in-out infinite;
    }

    @keyframes scoreGlow {
        0% { box-shadow: 0 0 5px yellow; }
        50% { box-shadow: 0 0 15px yellow; }
        100% { box-shadow: 0 0 5px yellow; }
    }

    @keyframes winnerScoreGlow {
        0% { box-shadow: 0 0 5px gold; }
        50% { box-shadow: 0 0 20px gold; }
        100% { box-shadow: 0 0 5px gold; }
    }
    
    .player2-controls {
        display: flex;
        gap: 10px;
        align-items: center;
    }

    .player2-controls select {
        padding: 5px;
        border-radius: 5px;
        background: transparent;
        color: inherit;
    }

    .theme-dark .player2-controls select {
        background: #444;
        color: white;
        border: 1px solid #666;
    }

    .theme-light .player2-controls select {
        background: #ddd;
        color: #333;
        border: 1px solid #999;
    }
</style>
</head>
<body class="theme-dark">
    <div class="game-controls">
        <div class="grid-size-controls">
            <label for="gridWidth">Width:</label>
            <input type="number" id="gridWidth" min="5" max="20" value="10">
            <label for="gridHeight">Height:</label>
            <input type="number" id="gridHeight" min="5" max="20" value="10">
        </div>
        <div class="player2-controls">
            <label for="player2Type">Player 2:</label>
            <select id="player2Type" class="button">
                <option value="human">Human</option>
                <option value="greedy">Greedy</option>
                <option value="chicken">Chicken</option>
                <option value="strategem">Strategem</option>
                <option value="stretch">Stretch</option>
                <option value="greedy2">Greedy2</option>
                <option value="defensive">Defensive</option>
                <option value="perimeter">Perimeter</option>
                <option value="divide">Divide & Conquer</option>
                <option value="adaptive">Adaptive</option>
            </select>
        </div>
        <button class="button" id="themeToggle">Toggle Theme</button>
        <button class="button" id="restartBtn">New Game</button>
    </div>
    <h1>Color Territory Game</h1>
    <div class="score">
        <div id="player1Score" class="player-score">Player 1: 1</div>
        <div id="player2Score" class="player-score">Player 2: 1</div>
    </div>
    <div id="status">Player 1's turn</div>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="400" height="400"></canvas>
    </div>
    <div class="controls">
        <div class="color-buttons" id="colorButtons"></div>
        <button class="button" id="shuffleBtn">Shuffle Colors (Skip Turn)</button>
    </div>
<script>
let gridWidth = 10;
let gridHeight = 10;
let player2Type = 'human';
const player2TypeSelect = document.getElementById('player2Type');
let turnCounter = 0;
let lastChickenShuffleTurn = -5; // Initialize to allow shuffle on first turn

const moveHistory = {
    gridStates: [],
    player1Moves: [],
    maxHistoryLength: 5
};

const colors = ['#FF4136', '#2ECC40', '#0074D9', '#FFDC00', '#B10DC9'];
const cellSize = 40;
let grid = [];
let currentPlayer = 1;
let player1Cells = new Set();
let player2Cells = new Set();
let gameOver = false;

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const status = document.getElementById('status');
const colorButtons = document.getElementById('colorButtons');
const themeToggle = document.getElementById('themeToggle');
const shuffleBtn = document.getElementById('shuffleBtn');
const restartBtn = document.getElementById('restartBtn');
const gridWidthInput = document.getElementById('gridWidth');
const gridHeightInput = document.getElementById('gridHeight');

function getLineCells(startRow, startCol, endRow, endCol) {
    const cells = [];
    const dx = endCol - startCol;
    const dy = endRow - startRow;
    const steps = Math.max(Math.abs(dx), Math.abs(dy));
    
    if (steps === 0) return cells;
    
    const xIncrement = dx / steps;
    const yIncrement = dy / steps;
    
    for (let i = 0; i <= steps; i++) {
        cells.push({
            row: startRow + (yIncrement * i),
            col: startCol + (xIncrement * i)
        });
    }
    
    return cells;
}

function drawGrid() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw grid cells
    for(let i = 0; i < gridHeight; i++) {
        for(let j = 0; j < gridWidth; j++) {
            const cell = grid[i][j];
            
            // Set cell fill color and opacity
            ctx.fillStyle = cell.color;
            ctx.globalAlpha = cell.owner ? 
                (cell.owner === currentPlayer ? 1 : 0.5) : 1;
            
            // Fill cell
            ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
            
            // Draw cell border
            ctx.globalAlpha = 1;
            ctx.strokeStyle = 'gray';
            
            // Special border for owned cells
            if(cell.owner) {
                // Yellow glow and border for current player's cells
                if(cell.owner === currentPlayer) {
                    ctx.strokeStyle = 'yellow';
                    ctx.shadowColor = 'yellow';
                    ctx.shadowBlur = 5;
                } else {
                    ctx.strokeStyle = 'gray';
                    ctx.shadowBlur = 0;
                }
            }
            
            ctx.strokeRect(j * cellSize, i * cellSize, cellSize, cellSize);
            ctx.shadowBlur = 0; // Reset shadow for next cell
        }
    }
}

// Add function to update scores with visual feedback
function updateScores() {
    const player1ScoreElem = document.getElementById('player1Score');
    const player2ScoreElem = document.getElementById('player2Score');
    
    player1ScoreElem.textContent = `Player 1: ${player1Cells.size}`;
    player2ScoreElem.textContent = `Player 2: ${player2Cells.size}`;
    
    // Remove existing classes
    player1ScoreElem.classList.remove('current', 'winner');
    player2ScoreElem.classList.remove('current', 'winner');
    
    // Add 'current' class to current player's score
    if(!gameOver) {
        if(currentPlayer === 1) {
            player1ScoreElem.classList.add('current');
        } else {
            player2ScoreElem.classList.add('current');
        }
    } else {
        // Add 'winner' class if game is over
        if(player1Cells.size > player2Cells.size) {
            player1ScoreElem.classList.add('winner');
        } else if(player2Cells.size > player1Cells.size) {
            player2ScoreElem.classList.add('winner');
        }
    }
}

function countContiguousSameColor(row, col, color, visited) {
    // If out of bounds, return 0
    if (row < 0 || row >= gridHeight || col < 0 || col >= gridWidth) {
        return 0;
    }
    
    // If cell is owned or different color, return 0
    if (grid[row][col].owner || grid[row][col].color !== color) {
        return 0;
    }
    
    // If we've already visited this cell, return 0
    const cellKey = `${row},${col}`;
    if (visited.has(cellKey)) {
        return 0;
    }
    
    // Mark cell as visited
    visited.add(cellKey);
    
    // Count this cell (1) plus all adjacent cells of same color
    return 1 + 
        countContiguousSameColor(row - 1, col, color, visited) +
        countContiguousSameColor(row + 1, col, color, visited) +
        countContiguousSameColor(row, col - 1, color, visited) +
        countContiguousSameColor(row, col + 1, color, visited);
}

function findLargestColorGroups() {
    let groups = new Map(); // Map of color -> array of {row, col, size}
    let visited = new Set();

    for(let i = 0; i < gridHeight; i++) {
        for(let j = 0; j < gridWidth; j++) {
            if(!grid[i][j].owner && !visited.has(`${i},${j}`)) {
                const color = grid[i][j].color;
                const groupSize = countContiguousSameColor(i, j, color, new Set());
                
                if(!groups.has(color)) {
                    groups.set(color, []);
                }
                groups.get(color).push({
                    row: i,
                    col: j,
                    size: groupSize
                });
                visited.add(`${i},${j}`);
            }
        }
    }
    return groups;
}

function calculateGreedyMove() {
    const availableColors = getAdjacentColors();
    let bestColor = null;
    let maxAdjacentCount = -1;

    availableColors.forEach(color => {
        let totalAdjacentCount = 0;
        player2Cells.forEach(cell => {
            const [row, col] = cell.split(',').map(Number);
            [[row-1,col], [row+1,col], [row,col-1], [row,col+1]].forEach(([r, c]) => {
                if (r >= 0 && r < gridHeight && c >= 0 && c < gridWidth && 
                    !grid[r][c].owner) {
                    // Count adjacent cells of same color that aren't owned
                    [[r-1,c], [r+1,c], [r,c-1], [r,c+1]].forEach(([nr, nc]) => {
                        if (nr >= 0 && nr < gridHeight && nc >= 0 && nc < gridWidth && 
                            !grid[nr][nc].owner && grid[nr][nc].color === color) {
                            totalAdjacentCount++;
                        }
                    });
                }
            });
        });

        if (totalAdjacentCount > maxAdjacentCount) {
            maxAdjacentCount = totalAdjacentCount;
            bestColor = color;
        }
    });

    return bestColor;
}

function calculateGreedy2Move() {
    const availableColors = getAdjacentColors();
    const colorGroups = findLargestColorGroups();
    let bestMove = null;
    let bestScore = -1;

    // Get player 2's territory center
    let p2CenterRow = 0, p2CenterCol = 0;
    player2Cells.forEach(cell => {
        const [row, col] = cell.split(',').map(Number);
        p2CenterRow += row;
        p2CenterCol += col;
    });
    p2CenterRow /= player2Cells.size;
    p2CenterCol /= player2Cells.size;

    // For each available color, evaluate possible moves
    availableColors.forEach(color => {
        if(!colorGroups.has(color)) return;
        
        // Sort groups by size
        const groups = colorGroups.get(color).sort((a, b) => b.size - a.size);
        
        for(const group of groups) {
            // Check if path is blocked by player 1
            let blocked = false;
            let pathCells = getLineCells(p2CenterRow, p2CenterCol, group.row, group.col);
            
            for(const cell of pathCells) {
                if(player1Cells.has(`${Math.round(cell.row)},${Math.round(cell.col)}`)) {
                    blocked = true;
                    break;
                }
            }
            
            if(!blocked) {
                const score = group.size * 100 - // Prioritize larger groups
                    Math.sqrt( // Distance penalty
                        Math.pow(group.row - p2CenterRow, 2) + 
                        Math.pow(group.col - p2CenterCol, 2)
                    );
                
                if(score > bestScore) {
                    bestScore = score;
                    bestMove = color;
                }
            }
        }
    });

    // Fallback to simple adjacent count if no unblocked paths found
    if(!bestMove) {
        let maxCount = 0;
        let candidates = [];
        
        availableColors.forEach(color => {
            let count = 0;
            player2Cells.forEach(cell => {
                const [row, col] = cell.split(',').map(Number);
                [[row-1,col], [row+1,col], [row,col-1], [row,col+1]].forEach(([r, c]) => {
                    if(r >= 0 && r < gridHeight && c >= 0 && c < gridWidth && 
                       !grid[r][c].owner && grid[r][c].color === color) {
                        count++;
                    }
                });
            });
            
            if(count > maxCount) {
                maxCount = count;
                candidates = [color];
            } else if(count === maxCount) {
                candidates.push(color);
            }
        });
        
        // Randomly select from equal candidates
        bestMove = candidates[Math.floor(Math.random() * candidates.length)];
    }

    return bestMove;
}

function calculateDefensiveMove() {
    const availableColors = getAdjacentColors();
    let bestColor = null;
    let maxDefenseScore = -1;

    // Get the boundary of player 1's territory
    const player1Boundary = new Set();
    player1Cells.forEach(cell => {
        const [row, col] = cell.split(',').map(Number);
        [[row-1,col], [row+1,col], [row,col-1], [row,col+1]].forEach(([r, c]) => {
            if (r >= 0 && r < gridHeight && c >= 0 && c < gridWidth && !grid[r][c].owner) {
                player1Boundary.add(`${r},${c}`);
            }
        });
    });

    availableColors.forEach(color => {
        let defenseScore = 0;
        // Count how many cells this color would block from player 1
        player1Boundary.forEach(cell => {
            const [row, col] = cell.split(',').map(Number);
            if (grid[row][col].color === color) {
                const visited = new Set();
                defenseScore += countContiguousSameColor(row, col, color, visited);
            }
        });

        if (defenseScore > maxDefenseScore) {
            maxDefenseScore = defenseScore;
            bestColor = color;
        }
    });

    return bestColor || availableColors[0];
}

function calculatePerimeterMove() {
    const availableColors = getAdjacentColors();
    let bestColor = null;
    let maxPerimeterScore = -1;

    availableColors.forEach(color => {
        let perimeterScore = 0;
        const tempTerritory = new Set(player2Cells); // Create temporary set of territory
        const newCells = new Set(); // Track new cells to avoid infinite loop
        
        // First pass: find all cells we could capture with this color
        player2Cells.forEach(cell => {
            const [row, col] = cell.split(',').map(Number);
            [[row-1,col], [row+1,col], [row,col-1], [row,col+1]].forEach(([r, c]) => {
                if (r >= 0 && r < gridHeight && c >= 0 && c < gridWidth && 
                    !grid[r][c].owner && grid[r][c].color === color) {
                    newCells.add(`${r},${c}`);
                }
            });
        });

        // Add new cells to temporary territory
        newCells.forEach(cell => tempTerritory.add(cell));

        // Calculate perimeter of this potential territory
        const perimeter = new Set();
        tempTerritory.forEach(cell => {
            const [row, col] = cell.split(',').map(Number);
            [[row-1,col], [row+1,col], [row,col-1], [row,col+1]].forEach(([r, c]) => {
                if (r >= 0 && r < gridHeight && c >= 0 && c < gridWidth && 
                    !tempTerritory.has(`${r},${c}`)) {
                    perimeter.add(`${r},${c}`);
                }
            });
        });

        // Score based on perimeter size and territory gain
        perimeterScore = perimeter.size + newCells.size;

        if (perimeterScore > maxPerimeterScore) {
            maxPerimeterScore = perimeterScore;
            bestColor = color;
        }
    });

    return bestColor || availableColors[0];
}

function calculateDivideMove() {
    const availableColors = getAdjacentColors();
    let bestColor = null;
    let maxDivideScore = -1;

    // Calculate center of the board
    const centerRow = Math.floor(gridHeight / 2);
    const centerCol = Math.floor(gridWidth / 2);

    availableColors.forEach(color => {
        let divideScore = 0;
        player2Cells.forEach(cell => {
            const [row, col] = cell.split(',').map(Number);
            [[row-1,col], [row+1,col], [row,col-1], [row,col+1]].forEach(([r, c]) => {
                if (r >= 0 && r < gridHeight && c >= 0 && c < gridWidth && 
                    !grid[r][c].owner && grid[r][c].color === color) {
                    // Score based on position relative to center and player 1
                    const distToCenter = Math.hypot(r - centerRow, c - centerCol);
                    const blockingScore = isBlockingPath(r, c) ? 2 : 1;
                    divideScore += countContiguousSameColor(r, c, color, new Set()) * 
                                 blockingScore / (distToCenter + 1);
                }
            });
        });

        if (divideScore > maxDivideScore) {
            maxDivideScore = divideScore;
            bestColor = color;
        }
    });

    return bestColor;
}

function calculateAdaptiveMove() {
    const player1Territory = player1Cells.size;
    const player2Territory = player2Cells.size;
    const territoryDiff = player1Territory - player2Territory;

    // If significantly behind, play aggressively
    if (territoryDiff > 5) {
        return calculateGreedy2Move();
    }
    // If ahead, play defensively
    else if (territoryDiff < -2) {
        return calculateDefensiveMove();
    }
    // If roughly equal, play strategically
    else {
        // Alternate between different strategies based on turn number
        switch (turnCounter % 3) {
            case 0:
                return calculatePerimeterMove();
            case 1:
                return calculateDivideMove();
            case 2:
                return calculateStrategemMove();
        }
    }
}

// Helper function for divide strategy
function isBlockingPath(row, col) {
    const player1Center = calculateTerritoryCenters(player1Cells);
    const player2Center = calculateTerritoryCenters(player2Cells);
    const pathCells = getLineCells(player1Center.row, player1Center.col, 
                                 player2Center.row, player2Center.col);
    
    return pathCells.some(cell => 
        Math.abs(cell.row - row) < 1 && Math.abs(cell.col - col) < 1
    );
}

// Modify the updateAvailableColors function to include new strategies
function updateAvailableColors() {
    const availableColors = getAdjacentColors();
    document.querySelectorAll('.color-btn').forEach(btn => {
        if (availableColors.includes(btn.dataset.color)) {
            btn.classList.add('available');
        } else {
            btn.classList.remove('available');
        }
    });

    // Add AI move handling
    if (!gameOver && currentPlayer === 2 && player2Type !== 'human') {
        setTimeout(() => {
            let selectedColor;
            switch(player2Type) {
                case 'greedy':
                    selectedColor = calculateGreedyMove();
                    break;
                case 'greedy2':
                    selectedColor = calculateGreedy2Move();
                    break;
                case 'chicken':
                    if (shouldChickenShuffle()) {
                        shuffleBtn.click();
                        return;
                    }
                    selectedColor = calculateChickenMove();
                    break;
                case 'stretch':
                    selectedColor = calculateStretchMove();
                    break;
                case 'strategem':
                    selectedColor = calculateStrategemMove();
                    break;
                case 'defensive':
                    selectedColor = calculateDefensiveMove();
                    break;
                case 'perimeter':
                    selectedColor = calculatePerimeterMove();
                    break;
                case 'divide':
                    selectedColor = calculateDivideMove();
                    break;
                case 'adaptive':
                    selectedColor = calculateAdaptiveMove();
                    break;
            }
            if (selectedColor) {
                handleColorSelect(selectedColor);
            }
        }, 1000); // 1 second delay for AI moves
    }
}

function playSelectSound() {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
    
    oscillator.start();
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
    
    setTimeout(() => {
        oscillator.stop();
    }, 100);
}

function playVictorySound() {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    oscillator.type = 'square';
    oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);
    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
    
    oscillator.start();
    
    setTimeout(() => {
        oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime);
    }, 100);
    
    setTimeout(() => {
        oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime);
    }, 200);
    
    setTimeout(() => {
        oscillator.frequency.setValueAtTime(1046.50, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
    }, 300);
    
    setTimeout(() => {
        oscillator.stop();
    }, 600);
}

function playShuffleSound() {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    oscillator.type = 'triangle';
    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
    
    // Play ascending notes
    oscillator.start();
    oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
    oscillator.frequency.linearRampToValueAtTime(600, audioContext.currentTime + 0.2);
    
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
    
    setTimeout(() => {
        oscillator.stop();
    }, 300);
}

function shouldChickenShuffle() {
    // Check if enough turns have passed since last shuffle
    if (turnCounter - lastChickenShuffleTurn < 5) {
        return false;
    }

    // Check potential threats from Player 1
    const player1Colors = getAdjacentColors();
    for (const color of player1Colors) {
        let maxGroupSize = 0;
        let totalGain = 0;
        
        player1Cells.forEach(cell => {
            const [row, col] = cell.split(',').map(Number);
            [[row-1,col], [row+1,col], [row,col-1], [row,col+1]].forEach(([r, c]) => {
                if (r >= 0 && r < gridHeight && c >= 0 && c < gridWidth && 
                    !grid[r][c].owner && grid[r][c].color === color) {
                    // Count contiguous cells of same color
                    const visited = new Set();
                    const groupSize = countContiguousSameColor(r, c, color, visited);
                    maxGroupSize = Math.max(maxGroupSize, groupSize);
                    totalGain += groupSize;
                }
            });
        });

        // If there's a block of 4 or more cells or total gain would be 8+ cells
        if (maxGroupSize >= 4 || totalGain >= 8) {
            return true;
        }
    }
    
    return false;
}

// Add helper function to find best color for Chicken's normal move
function calculateChickenMove() {
    const availableColors = getAdjacentColors();
    let bestColor = null;
    let maxGain = 0;

    availableColors.forEach(color => {
        let totalGain = 0;
        player2Cells.forEach(cell => {
            const [row, col] = cell.split(',').map(Number);
            [[row-1,col], [row+1,col], [row,col-1], [row,col+1]].forEach(([r, c]) => {
                if (r >= 0 && r < gridHeight && c >= 0 && c < gridWidth && 
                    !grid[r][c].owner && grid[r][c].color === color) {
                    const visited = new Set();
                    totalGain += countContiguousSameColor(r, c, color, visited);
                }
            });
        });

        if (totalGain > maxGain) {
            maxGain = totalGain;
            bestColor = color;
        }
    });

    return bestColor;
}

function calculateStretchMove() {
    const availableColors = getAdjacentColors();
    let bestColor = null;
    let bestScore = -1;

    // Get centers of both players' territories
    let p1CenterRow = 0, p1CenterCol = 0;
    let p2CenterRow = 0, p2CenterCol = 0;

    player1Cells.forEach(cell => {
        const [row, col] = cell.split(',').map(Number);
        p1CenterRow += row;
        p1CenterCol += col;
    });
    p1CenterRow /= player1Cells.size;
    p1CenterCol /= player1Cells.size;

    player2Cells.forEach(cell => {
        const [row, col] = cell.split(',').map(Number);
        p2CenterRow += row;
        p2CenterCol += col;
    });
    p2CenterRow /= player2Cells.size;
    p2CenterCol /= player2Cells.size;

    // Direction vector from p2 to p1
    const dirRow = p1CenterRow - p2CenterRow;
    const dirCol = p1CenterCol - p2CenterCol;

    availableColors.forEach(color => {
        let score = 0;
        player2Cells.forEach(cell => {
            const [row, col] = cell.split(',').map(Number);
            
            // Check adjacent cells
            [[row-1,col], [row+1,col], [row,col-1], [row,col+1]].forEach(([r, c]) => {
                if (r >= 0 && r < gridHeight && c >= 0 && c < gridWidth && 
                    !grid[r][c].owner && grid[r][c].color === color) {
                    
                    // Calculate how well this move aligns with direction to player 1
                    const cellDirRow = r - p2CenterRow;
                    const cellDirCol = c - p2CenterCol;
                    
                    // Dot product to measure alignment
                    const alignment = (cellDirRow * dirRow + cellDirCol * dirCol) / 
                        (Math.sqrt(dirRow * dirRow + dirCol * dirCol) * 
                         Math.sqrt(cellDirRow * cellDirRow + cellDirCol * cellDirCol) || 1);
                    
                    // Count contiguous cells
                    const visited = new Set();
                    const groupSize = countContiguousSameColor(r, c, color, visited);
                    
                    // Score based on group size and alignment
                    score += groupSize * (alignment + 1); // +1 to avoid negative scores
                }
            });
        });

        if (score > bestScore) {
            bestScore = score;
            bestColor = color;
        }
    });

    // If no good moves found, just pick first available color
    return bestColor || availableColors[0];
}

function calculateStrategemMove() {
    // Record current grid state 
    const currentGridState = grid.map(row => row.map(cell => ({
        color: cell.color,
        owner: cell.owner
    })));
    
    moveHistory.gridStates.push(currentGridState);
    if (moveHistory.gridStates.length > moveHistory.maxHistoryLength) {
        moveHistory.gridStates.shift();
        moveHistory.player1Moves.shift();
    }

    // Analyze player 1's behavior if we have enough history
    if (moveHistory.gridStates.length >= 3) {
        let towardsPlayer2Count = 0;
        let expansionCount = 0;
        let shuffleOnLargeGainCount = 0;
        
        // Get player territories' centers
        let p1Center = calculateTerritoryCenters(player1Cells);
        let p2Center = calculateTerritoryCenters(player2Cells);
        
        // Analyze previous moves
        for (let i = 1; i < moveHistory.player1Moves.length; i++) {
            const move = moveHistory.player1Moves[i];
            if (move.type === 'shuffle') {
                // Check if player 2 had large potential gain
                const previousState = moveHistory.gridStates[i-1];
                const potentialGain = calculatePotentialGain(previousState, 2);
                if (potentialGain >= 8) {
                    shuffleOnLargeGainCount++;
                }
            } else {
                // Check if move was towards player 2's territory
                const moveCenter = calculateTerritoryCenters(move.newCells);
                const towardsPlayer2 = isMovingTowards(moveCenter, p1Center, p2Center);
                if (towardsPlayer2) {
                    towardsPlayer2Count++;
                }
                
                // Check if move was primarily for expansion
                if (move.territoryGain >= 4) {
                    expansionCount++;
                }
            }
        }

        // Determine strategy based on analysis
        if (shuffleOnLargeGainCount >= 2) {
            // Player 1 tends to shuffle on large gains, do the same
            const player1PotentialGain = calculatePotentialGain(currentGridState, 1);
            if (player1PotentialGain >= 8 && (turnCounter - lastChickenShuffleTurn >= 5)) {
                shuffleBtn.click();
                return null;
            }
        }
        
        if (towardsPlayer2Count >= 2) {
            // Player 1 moves towards us, do the same
            return findBestDirectionalMove(p2Center, p1Center);
        }
        
        if (expansionCount >= 2) {
            // Player 1 focuses on expansion, do the same
            return findLargestExpansionMove();
        }
    }
    
    // Default strategy: Pick color with largest adjacent group
    return findLargestAdjacentGroup();
}

function calculateTerritoryCenters(cells) {
    let sumRow = 0, sumCol = 0;
    let count = 0;
    cells.forEach(cell => {
        const [row, col] = cell.split(',').map(Number);
        sumRow += row;
        sumCol += col;
        count++;
    });
    return {
        row: sumRow / count,
        col: sumCol / count
    };
}

function isMovingTowards(moveCenter, fromCenter, toCenter) {
    const originalDist = Math.hypot(
        toCenter.row - fromCenter.row,
        toCenter.col - fromCenter.col
    );
    const newDist = Math.hypot(
        toCenter.row - moveCenter.row,
        toCenter.col - moveCenter.col
    );
    return newDist < originalDist;
}

function calculatePotentialGain(gridState, playerNum) {
    const playerCells = playerNum === 1 ? player1Cells : player2Cells;
    let maxGain = 0;
    
    const availableColors = getAdjacentColors();
    availableColors.forEach(color => {
        let gain = 0;
        playerCells.forEach(cell => {
            const [row, col] = cell.split(',').map(Number);
            [[row-1,col], [row+1,col], [row,col-1], [row,col+1]].forEach(([r, c]) => {
                if (r >= 0 && r < gridHeight && c >= 0 && c < gridWidth && 
                    !gridState[r][c].owner && gridState[r][c].color === color) {
                    const visited = new Set();
                    gain += countContiguousSameColor(r, c, color, visited);
                }
            });
        });
        maxGain = Math.max(maxGain, gain);
    });
    
    return maxGain;
}

function findLargestAdjacentGroup() {
    const availableColors = getAdjacentColors();
    let bestColor = null;
    let maxGroupSize = 0;
    
    availableColors.forEach(color => {
        player2Cells.forEach(cell => {
            const [row, col] = cell.split(',').map(Number);
            [[row-1,col], [row+1,col], [row,col-1], [row,col+1]].forEach(([r, c]) => {
                if (r >= 0 && r < gridHeight && c >= 0 && c < gridWidth && 
                    !grid[r][c].owner && grid[r][c].color === color) {
                    const visited = new Set();
                    const groupSize = countContiguousSameColor(r, c, color, visited);
                    if (groupSize > maxGroupSize) {
                        maxGroupSize = groupSize;
                        bestColor = color;
                    }
                }
            });
        });
    });
    
    return bestColor || availableColors[0];
}

// New function to find the best directional move
function findBestDirectionalMove(fromCenter, toCenter) {
    const availableColors = getAdjacentColors();
    let bestColor = null;
    let bestScore = -1;
    
    const dirRow = toCenter.row - fromCenter.row;
    const dirCol = toCenter.col - fromCenter.col;
    const dirMagnitude = Math.sqrt(dirRow * dirRow + dirCol * dirCol);
    
    // Normalize direction vector
    const normalizedDirRow = dirRow / dirMagnitude;
    const normalizedDirCol = dirCol / dirMagnitude;
    
    availableColors.forEach(color => {
        let score = 0;
        player2Cells.forEach(cell => {
            const [row, col] = cell.split(',').map(Number);
            
            // Check adjacent cells
            [[row-1,col], [row+1,col], [row,col-1], [row,col+1]].forEach(([r, c]) => {
                if (r >= 0 && r < gridHeight && c >= 0 && c < gridWidth && 
                    !grid[r][c].owner && grid[r][c].color === color) {
                    
                    // Vector from center to this cell
                    const cellDirRow = r - fromCenter.row;
                    const cellDirCol = c - fromCenter.col;
                    const cellMagnitude = Math.sqrt(cellDirRow * cellDirRow + cellDirCol * cellDirCol);
                    
                    // Calculate alignment with desired direction (dot product)
                    const alignment = (cellDirRow * normalizedDirRow + cellDirCol * normalizedDirCol) / cellMagnitude;
                    
                    // Count contiguous cells
                    const visited = new Set();
                    const groupSize = countContiguousSameColor(r, c, color, visited);
                    
                    // Score based on group size and alignment
                    score += groupSize * (alignment + 1); // Convert alignment to 0-2 range
                }
            });
        });
        
        if (score > bestScore) {
            bestScore = score;
            bestColor = color;
        }
    });
    
    return bestColor || availableColors[0];
}

// Modify handleColorSelect to record player 1's moves:
function handleColorSelect(color) {
    const initialCells = new Set(currentPlayer === 1 ? player1Cells : player2Cells);
    
    if(gameOver || !getAdjacentColors().includes(color)) return;
    
    turnCounter++; // Add this line early in the function
    playSelectSound();
    
    const playerCells = currentPlayer === 1 ? player1Cells : player2Cells;
    let changed = new Set();
    
    // Change player's existing territory to new color
    playerCells.forEach(cell => {
        const [row, col] = cell.split(',').map(Number);
        grid[row][col].color = color;
    });
    
    // Capture adjacent matching cells
    let newCells;
    do {
        newCells = false;
        playerCells.forEach(cell => {
            const [row, col] = cell.split(',').map(Number);
            [[row-1,col], [row+1,col], [row,col-1], [row,col+1]].forEach(([r, c]) => {
                if(r >= 0 && r < gridHeight && c >= 0 && c < gridWidth && 
                   !grid[r][c].owner && grid[r][c].color === color) {
                    grid[r][c].owner = currentPlayer;
                    playerCells.add(`${r},${c}`);
                    changed.add(`${r},${c}`);
                    newCells = true;
                }
            });
        });
    } while(newCells);
    
    currentPlayer = currentPlayer === 1 ? 2 : 1;
    drawGrid();
    status.textContent = `Player ${currentPlayer}'s turn`;
    
    // Check if current player has any moves available
    const availableColors = getAdjacentColors();
    if(availableColors.length === 0) {
        gameOver = true;
        const player1Score = player1Cells.size;
        const player2Score = player2Cells.size;
        
        let winner;
        if(player1Score > player2Score) {
            winner = 1;
        } else if(player2Score > player1Score) {
            winner = 2;
        }
        
        if(winner) {
            status.textContent = `Game Over! Player ${winner} wins!`;
            status.classList.add('winner-announcement');
            playVictorySound();
        } else {
            status.textContent = `Game Over! It's a tie!`;
        }
    }
    
    // Add before currentPlayer changes:
    if (currentPlayer === 1) {
        moveHistory.player1Moves.push({
            type: 'color',
            color: color,
            newCells: Array.from(changed),
            territoryGain: player1Cells.size - initialCells.size
        });
    }
    
    updateAvailableColors();
    updateScores();
}

// Modify shuffleBtn click handler to record shuffles:
shuffleBtn.addEventListener('click', () => {
    if(!gameOver) {
        if (currentPlayer === 1) {
            moveHistory.player1Moves.push({
                type: 'shuffle',
                turnCounter: turnCounter
            });
        }
        playShuffleSound();
        if (currentPlayer === 2 && player2Type === 'chicken') {
            lastChickenShuffleTurn = turnCounter;
        }
        distributeColors();
        currentPlayer = currentPlayer === 1 ? 2 : 1;
        drawGrid();
        status.textContent = `Player ${currentPlayer}'s turn`;
        updateAvailableColors();
        updateScores();
    }
});

restartBtn.addEventListener('click', () => {
    turnCounter = 0;
    lastChickenShuffleTurn = -5;
    gridWidth = parseInt(gridWidthInput.value);
    gridHeight = parseInt(gridHeightInput.value);
    
    if (gridWidth < 5) gridWidth = 5;
    if (gridWidth > 20) gridWidth = 20;
    if (gridHeight < 5) gridHeight = 5;
    if (gridHeight > 20) gridHeight = 20;
    
    gridWidthInput.value = gridWidth;
    gridHeightInput.value = gridHeight;
    
    updateCanvasSize();
    
    gameOver = false;
    currentPlayer = 1;
    player1Cells.clear();
    player2Cells.clear();
    status.className = '';
    status.textContent = "Player 1's turn";
    initializeGrid();
    drawGrid();
    updateAvailableColors();
    updateScores(); // This will now handle the score glow properly
});

player2TypeSelect.addEventListener('change', (e) => {
    player2Type = e.target.value;
});

function updateCanvasSize() {
    canvas.width = gridWidth * cellSize;
    canvas.height = gridHeight * cellSize;
}

function distributeColors() {
    const totalCells = gridWidth * gridHeight;
    const cellsPerColor = Math.floor(totalCells / colors.length);
    let colorCounts = colors.map(color => ({color, count: cellsPerColor}));
    const remainingCells = totalCells - (cellsPerColor * colors.length);
    
    for(let i = 0; i < remainingCells; i++) {
        colorCounts[i].count++;
    }

    let allCells = [];
    colorCounts.forEach(({color, count}) => {
        for(let i = 0; i < count; i++) {
            allCells.push(color);
        }
    });

    for(let i = allCells.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [allCells[i], allCells[j]] = [allCells[j], allCells[i]];
    }

    let cellIndex = 0;
    for(let i = 0; i < gridHeight; i++) {
        for(let j = 0; j < gridWidth; j++) {
            if(!grid[i][j].owner) {
                grid[i][j].color = allCells[cellIndex++];
            }
        }
    }
}

function initializeGrid() {
    grid = [];
    for(let i = 0; i < gridHeight; i++) {
        grid[i] = [];
        for(let j = 0; j < gridWidth; j++) {
            grid[i][j] = {
                color: null,
                owner: null
            };
        }
    }
    distributeColors();
    grid[0][0].owner = 1;
    grid[gridHeight-1][gridWidth-1].owner = 2;
    player1Cells.add('0,0');
    player2Cells.add(`${gridHeight-1},${gridWidth-1}`);
}

function getAdjacentColors() {
    const adjacentColors = new Set();
    const playerCells = currentPlayer === 1 ? player1Cells : player2Cells;
    
    playerCells.forEach(cell => {
        const [row, col] = cell.split(',').map(Number);
        [[row-1,col], [row+1,col], [row,col-1], [row,col+1]].forEach(([r, c]) => {
            if (r >= 0 && r < gridHeight && c >= 0 && c < gridWidth && !grid[r][c].owner) {
                adjacentColors.add(grid[r][c].color);
            }
        });
    });
    
    return Array.from(adjacentColors);
}

function createColorButtons() {
    colors.forEach(color => {
        const button = document.createElement('button');
        button.className = 'color-btn';
        button.style.backgroundColor = color;
        button.dataset.color = color;
        button.addEventListener('click', () => handleColorSelect(color));
        colorButtons.appendChild(button);
    });
    updateAvailableColors();
}

function handleColorSelect(color) {
    const initialCells = new Set(currentPlayer === 1 ? player1Cells : player2Cells);
    
    if(gameOver || !getAdjacentColors().includes(color)) return;
    
    turnCounter++; // Add this line early in the function
    playSelectSound();
    
    const playerCells = currentPlayer === 1 ? player1Cells : player2Cells;
    let changed = new Set();
    
    // Change player's existing territory to new color
    playerCells.forEach(cell => {
        const [row, col] = cell.split(',').map(Number);
        grid[row][col].color = color;
    });
    
    // Capture adjacent matching cells
    let newCells;
    do {
        newCells = false;
        playerCells.forEach(cell => {
            const [row, col] = cell.split(',').map(Number);
            [[row-1,col], [row+1,col], [row,col-1], [row,col+1]].forEach(([r, c]) => {
                if(r >= 0 && r < gridHeight && c >= 0 && c < gridWidth && 
                   !grid[r][c].owner && grid[r][c].color === color) {
                    grid[r][c].owner = currentPlayer;
                    playerCells.add(`${r},${c}`);
                    changed.add(`${r},${c}`);
                    newCells = true;
                }
            });
        });
    } while(newCells);
    
    currentPlayer = currentPlayer === 1 ? 2 : 1;
    drawGrid();
    status.textContent = `Player ${currentPlayer}'s turn`;
    
    // Check if current player has any moves available
    const availableColors = getAdjacentColors();
    if(availableColors.length === 0) {
        gameOver = true;
        const player1Score = player1Cells.size;
        const player2Score = player2Cells.size;
        
        let winner;
        if(player1Score > player2Score) {
            winner = 1;
        } else if(player2Score > player1Score) {
            winner = 2;
        }
        
        if(winner) {
            status.textContent = `Game Over! Player ${winner} wins!`;
            status.classList.add('winner-announcement');
            playVictorySound();
        } else {
            status.textContent = `Game Over! It's a tie!`;
        }
    }
    
    // Add before currentPlayer changes:
    if (currentPlayer === 1) {
        moveHistory.player1Moves.push({
            type: 'color',
            color: color,
            newCells: Array.from(changed),
            territoryGain: player1Cells.size - initialCells.size
        });
    }
    
    updateAvailableColors();
    updateScores();
}

// Modify updateAvailableColors function's AI section:
function updateAvailableColors() {
    const availableColors = getAdjacentColors();
    document.querySelectorAll('.color-btn').forEach(btn => {
        if (availableColors.includes(btn.dataset.color)) {
            btn.classList.add('available');
        } else {
            btn.classList.remove('available');
        }
    });

    // Add AI move handling
    if (!gameOver && currentPlayer === 2 && player2Type !== 'human') {
        setTimeout(() => {
            let selectedColor;
            switch(player2Type) {
                case 'greedy':
                    selectedColor = calculateGreedyMove();
                    break;
                case 'greedy2':
                    selectedColor = calculateGreedy2Move();
                    break;
                case 'chicken':
                    if (shouldChickenShuffle()) {
                        shuffleBtn.click();
                        return;
                    }
                    selectedColor = calculateChickenMove();
                    break;
                case 'stretch':
                    selectedColor = calculateStretchMove();
                    break;
                case 'strategem':
                    selectedColor = calculateStrategemMove();
                    break;
                case 'defensive':
                    selectedColor = calculateDefensiveMove();
                    break;
                case 'perimeter':
                    selectedColor = calculatePerimeterMove();
                    break;
                case 'divide':
                    selectedColor = calculateDivideMove();
                    break;
                case 'adaptive':
                    selectedColor = calculateAdaptiveMove();
                    break;
            }
            if (selectedColor) {
                handleColorSelect(selectedColor);
            }
        }, 1000); // 1 second delay for AI moves
    }
}

// Initialize game
initializeGrid();
createColorButtons();
drawGrid();

// Theme toggle functionality
themeToggle.addEventListener('click', () => {
    document.body.classList.toggle('theme-dark');
    document.body.classList.toggle('theme-light');
});

// Initialize with dark theme
document.body.classList.add('theme-dark');

</script>
</body>
</html>