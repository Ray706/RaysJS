<html><head><base href="/">
  <title>Simple 3D Modeler</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #menuBar {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background-color: #333;
      color: white;
      padding: 10px;
      z-index: 1001; 
      display: flex;
      gap: 20px;
      align-items: center;
    }
    #menuBar > div {
      cursor: pointer;
    }
    #viewportWindow {
      position: absolute; 
      left: 10px;
      top: 60px;
      width: calc(100% - 20px);
      height: calc(100vh - 70px); 
      touch-action: none;
      z-index: 0;
      overflow: hidden;
    }
    #modelCanvas { 
      width: calc(100% - 10px); 
      height: calc(100% - 20px); 
      display: block; 
      margin: 10px 10px 10px 0; 
    }
    .inline-window {
      position: absolute;
      background-color: #f0f0f0;
      border: 1px solid #ccc;
      padding: 10px;
      box-sizing: border-box;
      z-index: 10;
    }
    .inline-window.minimized .window-content {
      display: none;
    }
    .window-title-bar {
      background-color: #ddd;
      padding: 5px;
      margin-bottom: 10px;
      cursor: grab;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .window-title-bar button.minimize-button {
      padding: 0;
      margin: 0;
      border: none;
      background: none;
      cursor: pointer;
      font-size: 12px;
    }
    .window-content {
      padding: 10px;
    }
    .control-group { margin-bottom: 15px; }
    label { display: block; margin-bottom: 5px; }
    input[type="text"], select { width: 100%; padding: 8px; box-sizing: border-box; margin-bottom: 5px; }
    button { padding: 8px 12px; cursor: pointer; }
    #faceInfo { margin-top: 10px; }
    .resize-handle {
      position: absolute;
      right: 0;
      bottom: 0;
      width: 10px;
      height: 10px;
      background-color: #aaa;
      cursor: se-resize;
      z-index: 11;
    }
    #fileDropdown {
      position: absolute;
      top: 100%;
      left: 0;
      background-color: #fff;
      border: 1px solid #ccc;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      display: none;
      z-index: 1000;
    }
    #fileDropdown a {
      display: block;
      padding: 8px 12px;
      text-decoration: none;
      color: #333;
    }
    #fileDropdown a:hover {
      background-color: #f0f0f0;
    }
    .bounding-box-edge {
      display: none;
    }
    .hide {
      display: none !important; 
    }
    #windowsDropdown {
      position: absolute;
      top: 100%;
      left: 0;
      background-color: #fff;
      border: 1px solid #ccc;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      display: none;
      z-index: 1000;
    }
    #windowsDropdown a {
      display: block;
      padding: 8px 12px;
      text-decoration: none;
      color: #333;
    }
    #windowsDropdown a:hover {
      background-color: #f0f0f0;
    }
    .axis-label {
      padding: 2px;
      font-family: Arial, sans-serif;
      font-size: 14px;
      font-weight: bold;
      pointer-events: none;
    }
    .object-controls {
      margin-top: 10px;
      padding: 5px;
    }

    .object-controls label {
      display: block;
      margin-bottom: 5px;
    }

    .object-controls input {
      width: 100%;
      margin-bottom: 10px;
    }
    #zoomFooter {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background-color: #333;
      color: white;
      padding: 5px 10px;
      text-align: right;
      font-family: monospace;
      z-index: 1001;
    }

    /* Add new styles */
    .collapsible-content {
      display: none; 
      transition: all 0.3s ease;
    }

    .collapsible-content.expanded {
      display: block;
    }

    .collapsible-header {
      cursor: pointer;
      padding: 10px; 
      background: #eee;
      margin-bottom: 5px;
      user-select: none;
      touch-action: manipulation; 
      -webkit-tap-highlight-color: transparent; 
    }

    .collapsible-header.expanded::before {
      transform: rotate(90deg);
    }
    .collapsible-header::before {
      content: 'â–¶';
      display: inline-block;
      margin-right: 10px; 
      transition: transform 0.2s;
    }
    
    .menu-spacer {
      flex-grow: 1;
    }

    #rotateObjectTool, #drawSplineTool {
      padding: 5px 15px;
      cursor: pointer;
    }

    .rotation-controls {
      margin-top: 15px;
    }

    .rotation-control {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
      gap: 10px;
    }

    .rotation-slider {
      flex-grow: 1;
      margin: 0 10px;
    }

    .rotation-value {
      width: 60px;
      text-align: right;
    }

    #rotationPreviewCanvas {
      display: block;
      margin: 0 auto;
      touch-action: none;
    }

    #rotateObjectWindow {
      width: 300px;
    }
  </style>
</head>
<body>
  <div id="menuBar">
    <div id="fileMenu">File
      <div id="fileDropdown" style="position: absolute; background-color: #fff; border: 1px solid #ccc; display: none;">
        <a href="#" id="newSceneOption" style="display: block; padding: 5px 10px; text-decoration: none; color: #000;">New</a>
        <a href="#" id="saveSceneOption" style="display: block; padding: 5px 10px; text-decoration: none; color: #000;">Save Scene</a>
        <a href="#" id="loadSceneOption" style="display: block; padding: 5px 10px; text-decoration: none; color: #000;">Load Scene</a>
      </div>
    </div>
    <div>Settings</div>
    <div>About</div>
    <div id="windowsMenu">Windows
      <div id="windowsDropdown" style="position: absolute; background-color: #fff; border: 1px solid #ccc; display: none;">
        <a href="#" id="toggleViewport" style="display: block; padding: 5px 10px; text-decoration: none; color: #000;">Scene View</a>
        <a href="#" id="toggleSceneControls" style="display: block; padding: 5px 10px; text-decoration: none; color: #000;">Scene Objects</a>
        <a href="#" id="toggleSelectedObject" style="display: block; padding: 5px 10px; text-decoration: none; color: #000;">Selected Object</a>
        <a href="#" id="togglePointEditor" style="display: block; padding: 5px 10px; text-decoration: none; color: #000;">Point Editor</a>
      </div>
    </div>
    <div class="menu-spacer" style="flex-grow: 1;"></div>
    <div id="rotateObjectTool">Rotate Object</div>
    <div id="drawSplineTool">Draw Spline</div>
  </div>

  <div id="viewportWindow" class="inline-window">
    <div class="window-title-bar" id="viewportTitle">
      Scene View
      <div>
        <button class="minimize-button" data-target="viewportWindow">-</button>
        <button id="maximizeViewport">M</button>
      </div>
    </div>
    <canvas id="modelCanvas"></canvas>
    <div class="resize-handle"></div>
  </div>

  <div id="sceneControls" class="inline-window" style="left: 10px; top: 60px;">
    <div class="window-title-bar" id="sceneControlsTitle">
      Scene Objects
      <button class="minimize-button" data-target="sceneControls">-</button>
    </div>
    <div class="window-content">
      <div class="control-group">
        <button id="addObject">Add Object</button>
        <select id="objectType">
          <option value="Plane">Plane</option>
          <option value="BeveledPlane">Beveled Plane</option>
          <option value="Cube">Cube</option>
          <option value="Sphere">Sphere</option>
          <option value="Octahedron">Octahedron</option>
          <option value="Dodecahedron">Dodecahedron</option>
          <option value="Cylinder">Cylinder</option>
          <option value="Pyramid">Pyramid</option>
          <option value="Cone">Cone</option>
          <option value="Torus">Torus</option>
          <option value="Custom">Custom</option>
        </select>
      </div>
      <div class="object-controls">
        <label for="objectSize">Object Size:</label>
        <input type="number" id="objectSize" value="1" min="0.1" max="10" step="0.1">
        
        <label for="polygonCount">Polygon Count:</label>
        <input type="number" id="polygonCount" value="32" min="3" max="128" step="1">
      </div>
      <div id="objectOptions"></div>
      <div class="control-group">
        <label for="loadFile">Load Geometry:</label>
        <input type="file" id="loadFile">
      </div>
    </div>
  </div>

  <div id="selectedObjectWindow" class="inline-window" style="left: 10px; top: 350px;">
    <div class="window-title-bar" id="selectedObjectTitle">
      Selected Object
      <button class="minimize-button" data-target="selectedObjectWindow">-</button>
    </div>
    <div class="window-content">
      <div class="control-group">
        <button id="prevObject">Previous</button>
        <button id="nextObject">Next</button>
      </div>
      
      <div class="control-group">
        <div class="collapsible-header">Current Position</div>
        <div class="collapsible-content">
          <div>
            <label>X:</label><input type="text" id="currentObjX" readonly>
            <label>Y:</label><input type="text" id="currentObjY" readonly>
            <label>Z:</label><input type="text" id="currentObjZ" readonly>
          </div>
        </div>
      </div>

      <div class="control-group">
        <div class="collapsible-header">Move To Position</div>
        <div class="collapsible-content">
          <div>
            <label>X:</label><input type="text" id="moveObjX">
            <label>Y:</label><input type="text" id="moveObjY">
            <label>Z:</label><input type="text" id="moveObjZ">
          </div>
          <button id="moveObjectBtn">Move Object</button>
        </div>
      </div>

      <div class="control-group">
        <button id="saveGeometry">Save Geometry</button>
      </div>
      <div class="control-group">
        <button id="deleteObjectBtn">Delete Object</button>
      </div>
      <div class="control-group">
        <button id="centerObjectBtn">Center in View</button>
      </div>
      <div class="control-group">
        <button id="toggleRotateWindow">Show Rotation Controls</button>
      </div>
    </div>
  </div>

  <div id="pointEditorWindow" class="inline-window" style="left: 10px; top: 550px;">
    <div class="window-title-bar" id="pointEditorTitle">
      Point Editor
      <button class="minimize-button" data-target="pointEditorWindow">-</button>
    </div>
    <div class="window-content">
      <div class="control-group">
        <label>
          <input type="checkbox" id="pointGroupToggle">
          Point Group
        </label>
      </div>
      <div class="control-group">
        <button id="prevPoint">Previous Point</button>
        <button id="nextPoint">Next Point</button>
      </div>

      <div class="control-group">
        <div class="collapsible-header">Current Point Position</div>
        <div class="collapsible-content">
          <div>
            <label>X:</label><input type="text" id="currentPointX" readonly>
            <label>Y:</label><input type="text" id="currentPointY" readonly>  
            <label>Z:</label><input type="text" id="currentPointZ" readonly>
          </div>
        </div>
      </div>

      <div class="control-group">
        <div class="collapsible-header">Move To Position</div>
        <div class="collapsible-content">
          <div>
            <label>X:</label><input type="text" id="movePointX">
            <label>Y:</label><input type="text" id="movePointY">
            <label>Z:</label><input type="text" id="movePointZ">
          </div>
          <button id="movePointBtn">Move Point</button>
        </div>
      </div>
    </div>
  </div>

  <div id="rotateObjectWindow" class="inline-window" style="right: 10px; top: 60px;">
    <div class="window-title-bar" id="rotateObjectTitle">
      Rotate Object
      <button class="minimize-button" data-target="rotateObjectWindow">-</button>
    </div>
    <div class="window-content">
      <canvas id="rotationPreviewCanvas" width="200" height="200" style="border: 1px solid #ccc;"></canvas>
      
      <div class="rotation-controls">
        <div class="rotation-control">
          <label>X:</label>
          <input type="range" id="rotateX" min="0" max="360" value="0" class="rotation-slider">
          <input type="number" id="rotateXValue" value="0" min="0" max="360" class="rotation-value">
        </div>
        
        <div class="rotation-control">
          <label>Y:</label>
          <input type="range" id="rotateY" min="0" max="360" value="0" class="rotation-slider">
          <input type="number" id="rotateYValue" value="0" min="0" max="360" class="rotation-value">
        </div>
        
        <div class="rotation-control">
          <label>Z:</label>
          <input type="range" id="rotateZ" min="0" max="360" value="0" class="rotation-slider">
          <input type="number" id="rotateZValue" value="0" min="0" max="360" class="rotation-value">
        </div>
      </div>
    </div>
  </div>

  <div id="controls" style="position: absolute; top: 60px; right: 10px; background-color: #f0f0f0; padding: 20px; box-sizing: border-box; z-index: 10;" class="hide">
  </div>

  <div id="zoomFooter">Zoom: 1.00x</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/renderers/CSS2DRenderer.js"></script>
  <script>let scene, camera, renderer, controls, labelRenderer;
let sceneObjects = [];
let currentObjectIndex = 0;
let customGeometryData = null;
const canvas = document.getElementById('modelCanvas');
const viewportWindow = document.getElementById('viewportWindow');
const addObjectButton = document.getElementById('addObject');
const objectTypeSelect = document.getElementById('objectType');
const objectOptionsDiv = document.getElementById('objectOptions');
const prevObjectButton = document.getElementById('prevObject');
const nextObjectButton = document.getElementById('nextObject');
const maximizeViewportButton = document.getElementById('maximizeViewport');
const currentObjX = document.getElementById('currentObjX');
const currentObjY = document.getElementById('currentObjY');
const currentObjZ = document.getElementById('currentObjZ');
const moveObjX = document.getElementById('moveObjX');
const moveObjY = document.getElementById('moveObjY');
const moveObjZ = document.getElementById('moveObjZ');
const moveObjectBtn = document.getElementById('moveObjectBtn');
let isViewportMaximized = false;
let originalViewportState = {};
const newSceneOption = document.getElementById('newSceneOption');
const saveSceneOption = document.getElementById('saveSceneOption');
const loadSceneOption = document.getElementById('loadSceneOption');
let boundingBox = null;
let boundingBoxHelper = null;
let currentPointIndex = 0;
let pointMarker = null;
let isPointGroupEnabled = false;
function init() {
  scene = new THREE.Scene();
  const axesHelper = new THREE.AxesHelper(2);
  scene.add(axesHelper);
  addObject('Cube');
  const labelX = document.createElement('div');
  labelX.className = 'axis-label';
  labelX.textContent = 'X';
  labelX.style.color = 'red';
  labelX.style.position = 'absolute';
  labelX.style.top = '40px';
  labelX.style.left = '0px';
  const labelY = document.createElement('div');
  labelY.className = 'axis-label';
  labelY.textContent = 'Y';
  labelY.style.color = 'green';
  labelY.style.position = 'absolute';
  labelY.style.top = '30px';
  labelY.style.left = '10px';
  labelY.style.overflow = 'hidden';
  const labelZ = document.createElement('div');
  labelZ.className = 'axis-label';
  labelZ.textContent = 'Z';
  labelZ.style.color = 'blue';
  labelZ.style.position = 'absolute';
  labelZ.style.top = '40px';
  labelZ.style.left = '0px';
  labelRenderer = new THREE.CSS2DRenderer();
  labelRenderer.setSize(viewportWindow.offsetWidth - 20, viewportWindow.offsetHeight - 60);
  labelRenderer.domElement.style.position = 'absolute';
  labelRenderer.domElement.style.top = '0';
  labelRenderer.domElement.style.left = '0';
  labelRenderer.domElement.style.pointerEvents = 'none';
  viewportWindow.appendChild(labelRenderer.domElement);
  const xLabel = new THREE.CSS2DObject(labelX);
  xLabel.position.set(2.2, -0.04, 0);
  scene.add(xLabel);
  const yLabel = new THREE.CSS2DObject(labelY);
  yLabel.position.set(0, 1.86, 0);
  scene.add(yLabel);
  const zLabel = new THREE.CSS2DObject(labelZ);
  zLabel.position.set(0, 0, 2.2);
  scene.add(zLabel);
  camera = new THREE.PerspectiveCamera(75, (window.innerWidth - 20) / (window.innerHeight - 70), 0.1, 1000);
  renderer = new THREE.WebGLRenderer({
    canvas: canvas,
    antialias: true
  });
  renderer.setSize(viewportWindow.offsetWidth - 20, viewportWindow.offsetHeight - 60);
  camera.position.z = 5;
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  setupDrag(viewportWindow, document.getElementById('viewportTitle'));
  setupDrag(document.getElementById('sceneControls'), document.getElementById('sceneControlsTitle'));
  setupDrag(document.getElementById('selectedObjectWindow'), document.getElementById('selectedObjectTitle'));
  setupResize(viewportWindow);
  setupMinimize();
  setupMaximize();
  setupFileMenu();
  setupWindowsMenu();
  setupSceneObjectControls();
  setupSelectedObjectControls();
  setupSaveLoad();
  setupPointEditor();
  setupDrag(document.getElementById('pointEditorWindow'), document.getElementById('pointEditorTitle'));
  setupObjectControls();
  setupCenterObject();
  setupRotationControls();
  setInterval(updateBoundingBox, 1);
  controls.addEventListener('change', () => {
    const zoom = camera.position.distanceTo(controls.target);
    document.getElementById('zoomFooter').textContent = `Zoom: ${zoom.toFixed(2)}x`;
  });
  initCollapsibles();
  animate();
}
function setupMinimize() {
  document.querySelectorAll('.minimize-button').forEach(button => {
    button.addEventListener('click', function () {
      const targetId = this.dataset.target;
      const targetWindow = document.getElementById(targetId);
      targetWindow.classList.toggle('minimized');
    });
  });
}
function setupMaximize() {
  maximizeViewportButton.addEventListener('click', () => {
    if (!isViewportMaximized) {
      originalViewportState = {
        left: viewportWindow.style.left,
        top: viewportWindow.style.top,
        width: viewportWindow.style.width,
        height: viewportWindow.style.height
      };
      viewportWindow.style.left = '0';
      viewportWindow.style.top = '50px';
      viewportWindow.style.width = '100%';
      viewportWindow.style.height = 'calc(100vh - 50px)';
      camera.aspect = viewportWindow.offsetWidth / viewportWindow.offsetHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(viewportWindow.offsetWidth, viewportWindow.offsetHeight);
      labelRenderer.setSize(viewportWindow.offsetWidth, viewportWindow.offsetHeight);
      isViewportMaximized = true;
      maximizeViewportButton.textContent = 'R';
    } else {
      viewportWindow.style.left = originalViewportState.left;
      viewportWindow.style.top = originalViewportState.top;
      viewportWindow.style.width = originalViewportState.width;
      viewportWindow.style.height = originalViewportState.height;
      camera.aspect = viewportWindow.offsetWidth / viewportWindow.offsetHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(viewportWindow.offsetWidth, viewportWindow.offsetHeight);
      labelRenderer.setSize(viewportWindow.offsetWidth, viewportWindow.offsetHeight);
      isViewportMaximized = false;
      maximizeViewportButton.textContent = 'M';
    }
  });
}
function setupResize(element) {
  const handle = element.querySelector('.resize-handle');
  if (!handle) return;
  let isResizing = false;
  let startX, startY, startWidth, startHeight;
  handle.addEventListener('mousedown', e => {
    isResizing = true;
    startX = e.clientX;
    startY = e.clientY;
    startWidth = element.offsetWidth;
    startHeight = element.offsetHeight;
    document.addEventListener('mousemove', doResize);
    document.addEventListener('mouseup', stopResize);
  });
  handle.addEventListener('touchstart', e => {
    if (e.touches.length === 1) {
      isResizing = true;
      startX = e.touches[0].clientX;
      startY = e.touches[0].clientY;
      startWidth = element.offsetWidth;
      startHeight = element.offsetHeight;
      document.addEventListener('touchmove', doResizeTouch, {
        passive: false
      });
      document.addEventListener('touchend', stopResizeTouch);
      document.addEventListener('touchcancel', stopResizeTouch);
    }
  }, {
    passive: false
  });
  function doResize(e) {
    if (!isResizing) return;
    const newWidth = startWidth + e.clientX - startX;
    const newHeight = startHeight + e.clientY - startY;
    element.style.width = newWidth + 'px';
    element.style.height = newHeight + 'px';
    if (element.id === 'viewportWindow') {
      camera.aspect = newWidth / newHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(newWidth, newHeight);
      labelRenderer.setSize(newWidth, newHeight);
    }
  }
  function doResizeTouch(e) {
    if (!isResizing || e.touches.length !== 1) return;
    e.preventDefault();
    const touch = e.touches[0];
    const newWidth = startWidth + touch.clientX - startX;
    const newHeight = startHeight + touch.clientY - startY;
    element.style.width = newWidth + 'px';
    element.style.height = newHeight + 'px';
    if (element.id === 'viewportWindow') {
      camera.aspect = newWidth / newHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(newWidth, newHeight);
      labelRenderer.setSize(newWidth, newHeight);
    }
  }
  function stopResize() {
    isResizing = false;
    document.removeEventListener('mousemove', doResize);
    document.removeEventListener('mouseup', stopResize);
  }
  function stopResizeTouch() {
    isResizing = false;
    document.removeEventListener('touchmove', doResizeTouch);
    document.removeEventListener('touchend', stopResizeTouch);
    document.removeEventListener('touchcancel', stopResizeTouch);
  }
}
function setupDrag(element, handle) {
  let isDragging = false;
  let offsetX, offsetY;
  handle.addEventListener('mousedown', e => {
    e.preventDefault();
    isDragging = true;
    offsetX = e.clientX - element.offsetLeft;
    offsetY = e.clientY - element.offsetTop;
    handle.style.cursor = 'grabbing';
  });
  handle.addEventListener('mouseup', () => {
    isDragging = false;
    handle.style.cursor = 'grab';
  });
  document.addEventListener('mousemove', e => {
    if (!isDragging) return;
    let newLeft = e.clientX - offsetX;
    let newTop = e.clientY - offsetY;
    const menuBarHeight = document.getElementById('menuBar').offsetHeight;
    if (newTop < menuBarHeight) {
      newTop = menuBarHeight;
    }
    element.style.left = newLeft + 'px';
    element.style.top = newTop + 'px';
  });
  handle.addEventListener('touchstart', e => {
    if (e.touches.length === 1) {
      isDragging = true;
      offsetX = e.touches[0].clientX - element.offsetLeft;
      offsetY = e.touches[0].clientY - element.offsetTop;
      handle.style.cursor = 'grabbing';
    }
  }, {
    passive: false
  });
  handle.addEventListener('touchend', () => {
    isDragging = false;
    handle.style.cursor = 'grab';
  });
  handle.addEventListener('touchcancel', () => {
    isDragging = false;
    handle.style.cursor = 'grab';
  });
  document.addEventListener('touchmove', e => {
    if (!isDragging || e.touches.length !== 1) return;
    e.preventDefault();
    let newLeft = e.touches[0].clientX - offsetX;
    let newTop = e.touches[0].clientY - offsetY;
    const menuBarHeight = document.getElementById('menuBar').offsetHeight;
    if (newTop < menuBarHeight) {
      newTop = menuBarHeight;
    }
    element.style.left = newLeft + 'px';
    element.style.top = newTop + 'px';
  }, {
    passive: false
  });
}
function setupSceneObjectControls() {
  addObjectButton.addEventListener('click', () => {
    addObject(objectTypeSelect.value);
  });
  prevObjectButton.addEventListener('click', () => {
    if (sceneObjects.length > 0) {
      currentObjectIndex = (currentObjectIndex - 1 + sceneObjects.length) % sceneObjects.length;
      updateSelection();
    }
  });
  nextObjectButton.addEventListener('click', () => {
    if (sceneObjects.length > 0) {
      currentObjectIndex = (currentObjectIndex + 1) % sceneObjects.length;
      updateSelection();
    }
  });
}
function addObject(type) {
  let geometry;
  const size = document.getElementById('objectSize').value || 1;
  const polygons = parseInt(document.getElementById('polygonCount').value) || 32;
  if (type === 'Custom') {
    if (!customGeometryData) {
      alert('No custom geometry has been loaded. Please load a geometry file first.');
      return;
    }
    geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(customGeometryData.vertices, 3));
    if (customGeometryData.indices && customGeometryData.indices.length > 0) {
      geometry.setIndex(customGeometryData.indices);
    }
    geometry.computeVertexNormals();
  } else {
    switch (type) {
      case 'Plane':
        geometry = new THREE.PlaneGeometry(size, size);
        break;
      case 'BeveledPlane':
        geometry = new THREE.ShapeGeometry(new THREE.Shape([new THREE.Vector2(0, 0), new THREE.Vector2(size, 0), new THREE.Vector2(size, size), new THREE.Vector2(0, size)]), {
          depth: size * 0.1,
          bevelEnabled: true,
          bevelSegments: Math.max(2, Math.floor(polygons / 8)),
          bevelSize: size * 0.05,
          bevelThickness: size * 0.05
        });
        break;
      case 'Cube':
        geometry = new THREE.BoxGeometry(size, size, size);
        break;
      case 'Sphere':
        geometry = new THREE.SphereGeometry(size / 2, polygons, polygons / 2);
        break;
      case 'Octahedron':
        geometry = new THREE.OctahedronGeometry(size / 2, Math.floor(Math.log2(polygons / 8)));
        break;
      case 'Dodecahedron':
        geometry = new THREE.DodecahedronGeometry(size / 2, Math.floor(Math.log2(polygons / 12)));
        break;
      case 'Cylinder':
        geometry = new THREE.CylinderGeometry(size / 2, size / 2, size, polygons);
        break;
      case 'Pyramid':
        geometry = new THREE.ConeGeometry(size / 2, size, 4);
        break;
      case 'Cone':
        geometry = new THREE.ConeGeometry(size / 2, size, polygons);
        break;
      case 'Torus':
        geometry = new THREE.TorusGeometry(size / 2, size / 5, polygons / 4, polygons);
        break;
    }
  }
  const material = new THREE.MeshBasicMaterial({
    color: 0x00ff00,
    wireframe: true
  });
  const mesh = new THREE.Mesh(geometry, material);
  scene.add(mesh);
  sceneObjects.push(mesh);
  currentObjectIndex = sceneObjects.length - 1;
  updateSelection();
  currentPointIndex = 0;
  updatePointDisplay();
}
function updateSelection() {
  sceneObjects.forEach(obj => {
    obj.material.wireframe = true;
  });
  const currentObjX = document.getElementById('currentObjX');
  const currentObjY = document.getElementById('currentObjY');
  const currentObjZ = document.getElementById('currentObjZ');
  if (sceneObjects.length > 0) {
    const obj = sceneObjects[currentObjectIndex];
    currentObjX.value = obj.position.x.toFixed(2);
    currentObjY.value = obj.position.y.toFixed(2);
    currentObjZ.value = obj.position.z.toFixed(2);
  }
  updateBoundingBox();
}
function setupSaveLoad() {
  const saveGeometryButton = document.getElementById('saveGeometry');
  const loadFile = document.getElementById('loadFile');
  saveGeometryButton.addEventListener('click', () => {
    saveGeometryToFile();
  });
  loadFile.addEventListener('change', event => {
    const file = event.target.files[0];
    if (file) {
      loadGeometryFromFile(file);
    }
  });
}
function saveGeometryToFile() {
  const currentObject = sceneObjects[currentObjectIndex];
  if (!currentObject) return;
  const geometryData = {
    vertices: Array.from(currentObject.geometry.attributes.position.array),
    indices: currentObject.geometry.index ? Array.from(currentObject.geometry.index.array) : [],
    type: currentObject.geometry.type
  };
  const geometryString = JSON.stringify(geometryData, null, 2);
  const blob = new Blob([geometryString], {
    type: 'application/json'
  });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'geometry.json';
  link.click();
  URL.revokeObjectURL(url);
}
function loadGeometryFromFile(file) {
  const reader = new FileReader();
  reader.onload = function (e) {
    try {
      customGeometryData = JSON.parse(e.target.result);
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(customGeometryData.vertices, 3));
      if (customGeometryData.indices && customGeometryData.indices.length > 0) {
        geometry.setIndex(customGeometryData.indices);
      }
      geometry.computeVertexNormals();
      const material = new THREE.MeshBasicMaterial({
        color: 0x00ff00,
        wireframe: true
      });
      const mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);
      sceneObjects.push(mesh);
      currentObjectIndex = sceneObjects.length - 1;
      updateSelection();
      updateObjectPositionDisplay();
      alert('Custom geometry loaded successfully! You can now add it to the scene using the "Custom" option.');
    } catch (error) {
      console.error('Error loading geometry:', error);
      alert('Error loading geometry file. Please check the file format.');
      customGeometryData = null;
    }
  };
  reader.readAsText(file);
}
function setupFileMenu() {
  const fileMenu = document.getElementById('fileMenu');
  const fileDropdown = document.getElementById('fileDropdown');
  const newSceneOption = document.getElementById('newSceneOption');
  const saveSceneOption = document.getElementById('saveSceneOption');
  const loadSceneOption = document.getElementById('loadSceneOption');
  const loadFile = document.getElementById('loadFile');
  if (!fileMenu || !fileDropdown || !newSceneOption || !saveSceneOption || !loadSceneOption || !loadFile) {
    console.error('Required elements for file menu not found');
    return;
  }
  newSceneOption.addEventListener('click', event => {
    event.preventDefault();
    resetScene();
    fileDropdown.style.display = 'none';
  });
  saveSceneOption.addEventListener('click', event => {
    event.preventDefault();
    saveSceneToFile();
    fileDropdown.style.display = 'none';
  });
  loadSceneOption.addEventListener('click', event => {
    event.preventDefault();
    loadFile.click();
    fileDropdown.style.display = 'none';
  });
  fileMenu.addEventListener('click', () => {
    fileDropdown.style.display = fileDropdown.style.display === 'none' ? 'block' : 'none';
  });
  document.addEventListener('click', event => {
    if (!fileMenu.contains(event.target)) {
      fileDropdown.style.display = 'none';
    }
  });
}
function setupWindowsMenu() {
  const windowsMenu = document.getElementById('windowsMenu');
  const windowsDropdown = document.getElementById('windowsDropdown');
  const toggleViewport = document.getElementById('toggleViewport');
  const toggleSceneControls = document.getElementById('toggleSceneControls');
  const toggleSelectedObject = document.getElementById('toggleSelectedObject');
  const togglePointEditor = document.getElementById('togglePointEditor');
  windowsMenu.addEventListener('click', () => {
    windowsDropdown.style.display = windowsDropdown.style.display === 'none' ? 'block' : 'none';
  });
  document.addEventListener('click', event => {
    if (!windowsMenu.contains(event.target)) {
      windowsDropdown.style.display = 'none';
    }
  });
  toggleViewport.addEventListener('click', event => {
    event.preventDefault();
    const viewport = document.getElementById('viewportWindow');
    viewport.classList.toggle('hide');
    windowsDropdown.style.display = 'none';
  });
  toggleSceneControls.addEventListener('click', event => {
    event.preventDefault();
    const sceneControls = document.getElementById('sceneControls');
    sceneControls.classList.toggle('hide');
    windowsDropdown.style.display = 'none';
  });
  toggleSelectedObject.addEventListener('click', event => {
    event.preventDefault();
    const selectedObject = document.getElementById('selectedObjectWindow');
    selectedObject.classList.toggle('hide');
    windowsDropdown.style.display = 'none';
  });
  togglePointEditor.addEventListener('click', event => {
    event.preventDefault();
    const pointEditor = document.getElementById('pointEditorWindow');
    pointEditor.classList.toggle('hide');
    windowsDropdown.style.display = 'none';
  });
}
function resetScene() {
  sceneObjects.forEach(obj => {
    scene.remove(obj);
    obj.geometry.dispose();
  });
  sceneObjects = [];
  addObject('Cube');
  currentObjectIndex = 0;
  updateSelection();
  currentPointIndex = 0;
  updatePointDisplay();
}
function setupSelectedObjectControls() {
  moveObjectBtn.addEventListener('click', () => {
    if (sceneObjects.length === 0) return;
    const obj = sceneObjects[currentObjectIndex];
    obj.position.set(parseFloat(moveObjX.value) || 0, parseFloat(moveObjY.value) || 0, parseFloat(moveObjZ.value) || 0);
    updateObjectPositionDisplay();
  });
  prevObjectButton.addEventListener('click', updateObjectPositionDisplay);
  nextObjectButton.addEventListener('click', updateObjectPositionDisplay);
  updateObjectPositionDisplay();
}
function setupCanvasInteraction() {}
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  const zoom = camera.position.distanceTo(controls.target);
  document.getElementById('zoomFooter').textContent = `Zoom: ${zoom.toFixed(2)}x`;
  renderer.render(scene, camera);
  labelRenderer.render(scene, camera);
}
function updateBoundingBox() {
  if (boundingBox) {
    scene.remove(boundingBox);
    boundingBox.geometry.dispose();
    boundingBox = null;
  }
  if (boundingBoxHelper) {
    scene.remove(boundingBoxHelper);
    boundingBoxHelper = null;
  }
  if (pointMarker) {
    scene.remove(pointMarker);
    pointMarker.geometry.dispose();
    pointMarker = null;
  }
  if (sceneObjects.length > 0) {
    const currentObject = sceneObjects[currentObjectIndex];
    boundingBoxHelper = new THREE.BoxHelper(currentObject, 0x00ffff);
    scene.add(boundingBoxHelper);
    const box = new THREE.Box3().setFromObject(currentObject);
    const geometry = new THREE.BoxGeometry(box.max.x - box.min.x, box.max.y - box.min.y, box.max.z - box.min.z);
    const material = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      wireframe: true,
      transparent: true,
      opacity: 0.5
    });
    boundingBox = new THREE.Mesh(geometry, material);
    boundingBox.position.copy(currentObject.position);
    boundingBox.rotation.copy(currentObject.rotation);
    scene.add(boundingBox);
    const positions = currentObject.geometry.attributes.position;
    if (positions && positions.count > 0) {
      const markerGeom = new THREE.BoxGeometry(0.1, 0.1, 0.1);
      const markerMat = new THREE.MeshBasicMaterial({
        color: 0x00ffff
      });
      pointMarker = new THREE.Mesh(markerGeom, markerMat);
      const x = positions.getX(currentPointIndex);
      const y = positions.getY(currentPointIndex);
      const z = positions.getZ(currentPointIndex);
      const worldPos = new THREE.Vector3(x, y, z);
      currentObject.localToWorld(worldPos);
      pointMarker.position.copy(worldPos);
      scene.add(pointMarker);
    }
  }
}
function updateObjectPositionDisplay() {
  if (sceneObjects.length === 0) return;
  const obj = sceneObjects[currentObjectIndex];
  currentObjX.value = obj.position.x.toFixed(2);
  currentObjY.value = obj.position.y.toFixed(2);
  currentObjZ.value = obj.position.z.toFixed(2);
}
function setupPointEditor() {
  const prevPointBtn = document.getElementById('prevPoint');
  const nextPointBtn = document.getElementById('nextPoint');
  const pointGroupToggle = document.getElementById('pointGroupToggle');
  const movePointBtn = document.getElementById('movePointBtn');
  pointGroupToggle.addEventListener('change', e => {
    isPointGroupEnabled = e.target.checked;
  });
  prevPointBtn.addEventListener('click', () => {
    if (sceneObjects.length === 0) return;
    const positions = sceneObjects[currentObjectIndex].geometry.attributes.position;
    const numPoints = positions.count;
    if (numPoints > 0) {
      if (isPointGroupEnabled) {
        let prevIndex = currentPointIndex;
        let currentPos = new THREE.Vector3(positions.getX(currentPointIndex), positions.getY(currentPointIndex), positions.getZ(currentPointIndex));
        do {
          prevIndex = (prevIndex - 1 + numPoints) % numPoints;
          let testPos = new THREE.Vector3(positions.getX(prevIndex), positions.getY(prevIndex), positions.getZ(prevIndex));
          if (!testPos.equals(currentPos) || prevIndex === currentPointIndex) {
            currentPointIndex = prevIndex;
            break;
          }
        } while (prevIndex !== currentPointIndex);
      } else {
        currentPointIndex = (currentPointIndex - 1 + numPoints) % numPoints;
      }
      updatePointDisplay();
    }
  });
  nextPointBtn.addEventListener('click', () => {
    if (sceneObjects.length === 0) return;
    const positions = sceneObjects[currentObjectIndex].geometry.attributes.position;
    const numPoints = positions.count;
    if (numPoints > 0) {
      if (isPointGroupEnabled) {
        let nextIndex = currentPointIndex;
        let currentPos = new THREE.Vector3(positions.getX(currentPointIndex), positions.getY(currentPointIndex), positions.getZ(currentPointIndex));
        do {
          nextIndex = (nextIndex + 1) % numPoints;
          let testPos = new THREE.Vector3(positions.getX(nextIndex), positions.getY(nextIndex), positions.getZ(nextIndex));
          if (!testPos.equals(currentPos) || nextIndex === currentPointIndex) {
            currentPointIndex = nextIndex;
            break;
          }
        } while (nextIndex !== currentPointIndex);
      } else {
        currentPointIndex = (currentPointIndex + 1) % numPoints;
      }
      updatePointDisplay();
    }
  });
  movePointBtn.addEventListener('click', () => {
    if (sceneObjects.length === 0) return;
    const positions = sceneObjects[currentObjectIndex].geometry.attributes.position;
    const currentObj = sceneObjects[currentObjectIndex];
    const newX = parseFloat(document.getElementById('movePointX').value) || 0;
    const newY = parseFloat(document.getElementById('movePointY').value) || 0;
    const newZ = parseFloat(document.getElementById('movePointZ').value) || 0;
    if (isPointGroupEnabled) {
      const currentPos = new THREE.Vector3(positions.getX(currentPointIndex), positions.getY(currentPointIndex), positions.getZ(currentPointIndex));
      for (let i = 0; i < positions.count; i++) {
        const testPos = new THREE.Vector3(positions.getX(i), positions.getY(i), positions.getZ(i));
        if (testPos.equals(currentPos)) {
          positions.setXYZ(i, newX, newY, newZ);
        }
      }
    } else {
      positions.setXYZ(currentPointIndex, newX, newY, newZ);
    }
    positions.needsUpdate = true;
    currentObj.geometry.computeVertexNormals();
    updatePointDisplay();
  });
}
function updatePointDisplay() {
  if (sceneObjects.length === 0) return;
  const currentObj = sceneObjects[currentObjectIndex];
  const positions = currentObj.geometry.attributes.position;
  const x = positions.getX(currentPointIndex);
  const y = positions.getY(currentPointIndex);
  const z = positions.getZ(currentPointIndex);
  document.getElementById('currentPointX').value = x.toFixed(2);
  document.getElementById('currentPointY').value = y.toFixed(2);
  document.getElementById('currentPointZ').value = z.toFixed(2);
  if (pointMarker) {
    const worldPos = new THREE.Vector3(x, y, z);
    currentObj.localToWorld(worldPos);
    pointMarker.position.copy(worldPos);
  }
}
function setupObjectControls() {
  const sizeInput = document.getElementById('objectSize');
  const polygonInput = document.getElementById('polygonCount');
  sizeInput.addEventListener('change', () => {
    if (sizeInput.value < 0.1) sizeInput.value = 0.1;
    if (sizeInput.value > 10) sizeInput.value = 10;
  });
  polygonInput.addEventListener('change', () => {
    if (polygonInput.value < 3) polygonInput.value = 3;
    if (polygonInput.value > 128) polygonInput.value = 128;
  });
}
function setupCenterObject() {
  const centerObjectBtn = document.getElementById('centerObjectBtn');
  centerObjectBtn.addEventListener('click', () => {
    if (sceneObjects.length === 0) return;
    const currentObject = sceneObjects[currentObjectIndex];
    const bbox = new THREE.Box3().setFromObject(currentObject);
    const center = bbox.getCenter(new THREE.Vector3());
    controls.target.copy(center);
    const distance = camera.position.distanceTo(controls.target);
    const direction = camera.position.clone().sub(controls.target).normalize();
    camera.position.copy(center).add(direction.multiplyScalar(distance));
    controls.update();
  });
}
window.addEventListener('resize', () => {
  if (!isViewportMaximized) {
    viewportWindow.style.width = `calc(100% - 20px)`;
    viewportWindow.style.height = `calc(100vh - 70px)`;
    camera.aspect = (window.innerWidth - 20) / (window.innerHeight - 70);
    camera.updateProjectionMatrix();
    renderer.setSize(viewportWindow.offsetWidth - 20, viewportWindow.offsetHeight - 60);
    labelRenderer.setSize(viewportWindow.offsetWidth - 20, viewportWindow.offsetHeight - 60);
  }
});
const deleteObjectBtn = document.getElementById('deleteObjectBtn');
deleteObjectBtn.addEventListener('click', () => {
  if (sceneObjects.length === 0) return;
  const obj = sceneObjects[currentObjectIndex];
  scene.remove(obj);
  obj.geometry.dispose();
  obj.material.dispose();
  sceneObjects.splice(currentObjectIndex, 1);
  if (sceneObjects.length === 0) {
    currentObjectIndex = 0;
  } else if (currentObjectIndex >= sceneObjects.length) {
    currentObjectIndex = sceneObjects.length - 1;
  }
  updateObjectPositionDisplay();
  updateBoundingBox();
});
function initCollapsibles() {
  document.querySelectorAll('.collapsible-header').forEach(header => {
    const toggleCollapsible = () => {
      header.classList.toggle('expanded');
      const content = header.nextElementSibling;
      content.classList.toggle('expanded');
    };
    header.addEventListener('click', toggleCollapsible);
    header.addEventListener('touchstart', e => {
      e.preventDefault();
      toggleCollapsible();
    }, {
      passive: false
    });
  });
}
function setupRotationControls() {
  const rotateWindow = document.getElementById('rotateObjectWindow');
  const canvas = document.getElementById('rotationPreviewCanvas');
  const ctx = canvas.getContext('webgl');
  let previewScene = new THREE.Scene();
  let previewCamera = new THREE.PerspectiveCamera(75, canvas.width / canvas.height, 0.1, 1000);
  let previewRenderer = new THREE.WebGLRenderer({
    canvas: canvas,
    antialias: true
  });
  const geometry = new THREE.BoxGeometry(2, 2, 2);
  const materials = [new THREE.MeshBasicMaterial({
    color: 0xff0000,
    wireframe: true,
    wireframeLinewidth: 2
  }), new THREE.MeshBasicMaterial({
    color: 0x00ff00,
    wireframe: true,
    wireframeLinewidth: 2
  }), new THREE.MeshBasicMaterial({
    color: 0x0000ff,
    wireframe: true,
    wireframeLinewidth: 2
  }), new THREE.MeshBasicMaterial({
    color: 0xffff00,
    wireframe: true,
    wireframeLinewidth: 2
  }), new THREE.MeshBasicMaterial({
    color: 0xff00ff,
    wireframe: true,
    wireframeLinewidth: 2
  }), new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    wireframe: true,
    wireframeLinewidth: 2
  })];
  const previewCube = new THREE.Mesh(geometry, materials);
  previewScene.add(previewCube);
  previewCamera.position.z = 5;
  const rotateX = document.getElementById('rotateX');
  const rotateY = document.getElementById('rotateY');
  const rotateZ = document.getElementById('rotateZ');
  const rotateXValue = document.getElementById('rotateXValue');
  const rotateYValue = document.getElementById('rotateYValue');
  const rotateZValue = document.getElementById('rotateZValue');
  function updateRotation() {
    if (sceneObjects.length === 0) return;
    const currentObj = sceneObjects[currentObjectIndex];
    const x = THREE.MathUtils.degToRad(parseFloat(rotateX.value));
    const y = THREE.MathUtils.degToRad(parseFloat(rotateY.value));
    const z = THREE.MathUtils.degToRad(parseFloat(rotateZ.value));
    currentObj.rotation.set(x, y, z);
    previewCube.rotation.set(x, y, z);
    updateBoundingBox();
    updatePointDisplay();
  }
  function updateSliderFromInput(slider, input) {
    let value = parseFloat(input.value) || 0;
    value = Math.max(0, Math.min(360, value));
    input.value = value;
    slider.value = value;
    updateRotation();
  }
  rotateX.addEventListener('input', () => {
    rotateXValue.value = rotateX.value;
    updateRotation();
  });
  rotateY.addEventListener('input', () => {
    rotateYValue.value = rotateY.value;
    updateRotation();
  });
  rotateZ.addEventListener('input', () => {
    rotateZValue.value = rotateZ.value;
    updateRotation();
  });
  rotateXValue.addEventListener('change', () => updateSliderFromInput(rotateX, rotateXValue));
  rotateYValue.addEventListener('change', () => updateSliderFromInput(rotateY, rotateYValue));
  rotateZValue.addEventListener('change', () => updateSliderFromInput(rotateZ, rotateZValue));
  function animatePreview() {
    requestAnimationFrame(animatePreview);
    previewRenderer.render(previewScene, previewCamera);
  }
  animatePreview();
  const rotateObjectTool = document.getElementById('rotateObjectTool');
  const toggleRotateWindow = document.getElementById('toggleRotateWindow');
  function toggleRotationWindow() {
    rotateWindow.classList.toggle('hide');
    toggleRotateWindow.textContent = rotateWindow.classList.contains('hide') ? 'Show Rotation Controls' : 'Hide Rotation Controls';
  }
  rotateObjectTool.addEventListener('click', toggleRotationWindow);
  toggleRotateWindow.addEventListener('click', toggleRotationWindow);
  setupDrag(rotateWindow, document.getElementById('rotateObjectTitle'));
}
init();
setupSelectedObjectControls();
setupPointEditor();
animate();
initCollapsibles();
initCollapsibles();
</script>
</body>
</html>
